---
layout: post
title: re2c帮助翻译
tag: ['re2c']
category: ['re2c帮助翻译']
a_id: 7
---
	



###NAME
	* re2c - convert regular-expressions to C/C++

###SYNOPSIS
    * re2c [-bdDefFghisuvVw1] [-o output] [-c [-t header]] file

###DESCRIPTION
       re2c  is a preprocessor that generates C-based recognizers from regular
       expressions.  The input to re2c consists of  C/C++  source  interleaved
       with comments of the form /*!re2c ... */ which contain scanner specifi-
       cations.  In the output these comments are  replaced  with  code  that,
       when  executed,  will  find  the next input token and then execute some
       user-supplied token-specific code.

       For example, given the following code

          char *scan(char *p)
          {
          /*!re2c
                  re2c:define:YYCTYPE  = "unsigned char";
                  re2c:define:YYCURSOR = p;
                  re2c:yyfill:enable   = 0;
                  re2c:yych:conversion = 1;
                  re2c:indent:top      = 1;
                  [0-9]+          {return p;}
                  [^]             {return (char*)0;}
          */
          }

       re2c -is will generate

          /* Generated by re2c on Sat Apr 16 11:40:58 1994 */
          char *scan(char *p)
          {
              {
                  unsigned char yych;

                  yych = (unsigned char)*p;
                  if(yych &lt;= ’/’) goto yy4;
                  if(yych &gt;= ’:’) goto yy4;
                  ++p;
                  yych = (unsigned char)*p;
                  goto yy7;
          yy3:
                  {return p;}
          yy4:
                  ++p;
                  yych = (unsigned char)*p;
                  {return char*)0;}
          yy6:
                  ++p;
                  yych = (unsigned char)*p;
          yy7:
                  if(yych &lt;= ’/’) goto yy3;
                  if(yych &lt;= ’9’) goto yy6;
                  goto yy3;
              }

          }

       You can place one /*!max:re2c */ comment that will  output  a  "#define
       YYMAXFILL  <n>"  line  that  holds  the  maximum  number  of characters
       required to parse the input. That is the maximum value  YYFILL(n)  will
       receive.  If  -1 is in effect then YYMAXFILL can only be triggered once
       after the last /*!re2c */.

       You can also use /*!ignore:re2c */ blocks that allows to  document  the
       scanner code and will not be part of the output.


###OPTIONS
       re2c provides the following options:

       -?     -h Invoke a short help.

       -b     Implies -s.  Use bit vectors as well in the attempt to coax bet-
              ter code out of the compiler.  Most  useful  for  specifications
              with  more  than  a few keywords (e.g. for most programming lan-
              guages).

       -c     Used to support (f)lex-like condition support.

       -d     Creates a parser that dumps information about the current  posi-
              tion  and  in which state the parser is while parsing the input.
              This is useful to debug parser issues and  states.  If  you  use
              this  switch  you  need to define a macro YYDEBUG that is called
              like a function with two  parameters:  void  YYDEBUG(int  state,
              char  current). The first parameter receives the state or -1 and
              the second parameter receives the input at the current cursor.

       --DD     Emit Graphviz dot data. It can then be processed with e.g.  "dot
              -Tpng  input.dot  >  output.png". Please note that scanners with
              many states may crash dot.

       --ee     Cross-compile from an ASCII platform to an EBCDIC one.

       --ff     Generate a scanner with support for storable state.  For details
              see below at SSCCAANNNNEERR WWIITTHH SSTTOORRAABBLLEE SSTTAATTEESS.

       --FF     Partial  support  for flex syntax. When this flag is active then
              named definitions must be surrounded by curly braces and can  be
              defined  without  an  equal sign and the terminating semi colon.
              Instead names are treated as direct double quoted strings.

       --gg     Generate a scanner that utilizes GCC’s  computed  goto  feature.
              That  is  rree22cc generates jump tables whenever a decision is of a
              certain complexity (e.g. a lot of if  conditions  are  otherwise
              necessary).  This  is  only useable with GCC and produces output
              that cannot be compiled with any other compiler. Note that  this
              implies  -b  and that the complexity threshold can be configured
              using the inplace configuration "cgoto:threshold".

       --ii     Do not output #line information. This is usefull when  you  want
              use  a CMS tool with the rree22cc output which you might want if you
              do not require your users to have rree22cc themselves when  building
              from your source.  --oo oouuttppuutt Specify the output file.

       --rr     Allows  reuse  of  scanner  definitions with ’//**!!uussee::rree22cc’ after
              every ’//**!!uussee::rree22cc’ block that follows. These blocks can contain
              inplace    configurations,    especially    ’rree22cc::ffllaaggss::ww’   and
              ’rree22cc::ffllaaggss::uu’.  That way it is  possible  to  create  the  same
              scanner  multiple times for different character types, different
              input  mechanisms   or   different   output   mechanisms.    The
              ’//**!!uussee::rree22cc’ blocks can also contain additional rules that will
              be appended to the set of rules in ’//**!!rruulleess::rree22cc’.

       --ss     Generate nested ifs for some switches.  Many compilers need this
              assist to generate better code.

       --tt     Create  a  header  file  that contains types for the (f)lex-like
              condition support.  This can only be activated  when  --cc  is  in
              use.

       --uu     Generate  a  parser  that  supports Unicode chars (UTF-32). This
              means the generated code can deal with any valid Unicode charac-
              ter  up  to 0x10FFFF. When UTF-8 or UTF-16 needs to be supported
              you need to convert the incoming stream  to  UTF-32  upon  input
              yourself.

       --vv     Show version information.

       --VV     Show the version as a number XXYYZZ.

       --ww     Create  a  parser that supports wide chars (UCS-2). This implies
              --ss and cannot be used together with --ee switch.

       --11     Force single pass generation, this cannot be  combined  with  -f
              and disables YYMAXFILL generation prior to last rree22cc block.

       ----nnoo--ggeenneerraattiioonn--ddaattee
              Suppress  date  output  in  the generated output so that it only
              shows the re2c version.

       --case-insensitive
              All strings are  case  insensitive,  so  all  "-expressions  are
              treated in the same way ’-expressions are.

       ----ccaassee--iinnvveerrtteedd
              Invert  the  meaning  of single and double quoted strings.  With
              this switch single quotes are case sensitive and  double  quotes
              are case insensitive.


IINNTTEERRFFAACCEE CCOODDEE
       Unlike  other scanner generators, rree22cc does not generate complete scan-
       ners: the user must supply some interface  code.   In  particular,  the
       user  must define the following macros or use the corresponding inplace
       configurations:

       YYCONDTYPE
              In --cc mode you can use --tt to generate a file that  contains  the
              enumeration  used  as conditions. Each of the values refers to a
              condition of a rule set.

       YYCTXMARKER
              _l-expression of type *YYCTYPE.  The generated code saves  trail-
              ing  context  backtracking information in YYCTXMARKER.  The user
              only needs to define this macro if a scanner specification  uses
              trailing context in one or more of its regular-expressions.

       YYCTYPE
              Type  used  to  hold  an input symbol.  Usually char or unsigned
              char.

       YYCURSOR
              _l-expression of type *YYCTYPE that points to the  current  input
              symbol.   The  generated  code  advances YYCURSOR as symbols are
              matched.  On entry, YYCURSOR is assumed to point  to  the  first
              character of the current token.  On exit, YYCURSOR will point to
              the first character of the following token.

       YYDEBUG(_s_t_a_t_e,_c_u_r_r_e_n_t_)
              This is only needed if the --dd flag was specified. It  allows  to
              easily  debug  the  generated  parser  by calling a user defined
              function for every state. The function should have the following
              signature:  _v_o_i_d  _Y_Y_D_E_B_U_G_(_i_n_t  _s_t_a_t_e_,  _c_h_a_r _c_u_r_r_e_n_t_).  The first
              parameter receives the state or  -1  and  the  second  parameter
              receives the input at the current cursor.

       YYFILL(_n)
              The  generated  code  "calls"  YYFILL(n)  when  the buffer needs
              (re)filling:  at least _n additional characters  should  be  pro-
              vided.  YYFILL(n)  should adjust YYCURSOR, YYLIMIT, YYMARKER and
              YYCTXMARKER as needed.  Note that for typical  programming  lan-
              guages  _n  will  be  the length of the longest keyword plus one.
              The user can place a comment of the form /*!max:re2c */ once  to
              insert  a  YYMAXFILL(n)  definition  that  is set to the maximum
              length value. If -1 switch is used then YYMAXFILL can  be  trig-
              gered only once after the last /*!re2c */ block.

       YYGETCONDITION()
              This  define  is used to get the condition prior to entering the
              scanner code when using --cc switch. The value must be initialized
              with a value from the enumeration YYCONDTYPE type.

       YYGETSTATE()
              The  user  only  needs  to  define this macro if the --ff flag was
              specified.  In that case,  the  generated  code  "calls"  YYGET-
              STATE()  at the very beginning of the scanner in order to obtain
              the saved state. YYGETSTATE() must return a signed integer.  The
              value  must be either -1, indicating that the scanner is entered
              for the first time,  or  a  value  previously  saved  by  YYSET-
              STATE(s).   In  the  second case, the scanner will resume opera-
              tions right after where the last YYFILL(n) was called.

       YYLIMIT
              Expression of type *YYCTYPE that marks the  end  of  the  buffer
              (YYLIMIT[-1]  is  the last character in the buffer).  The gener-
              ated code repeatedly compares YYCURSOR to YYLIMIT  to  determine
              when the buffer needs (re)filling.

       YYMARKER
              _l-expression  of  type *YYCTYPE.  The generated code saves back-
              tracking information in YYMARKER. Some easy scanners  might  not
              use this.

       YYMAXFILL
              This  will  be automatically defined by /*!max:re2c */ blocks as
              explained above.

       YYSETCONDITION(_c)
              This define is used to set the condition  in  transition  rules.
              This  is  only being used when --cc is active and transition rules
              are being used.

       YYSETSTATE(_s)
              The user only needs to define this macro  if  the  --ff  flag  was
              specified.   In that case, the generated code "calls" YYSETSTATE
              just before calling YYFILL(n).  The parameter to YYSETSTATE is a
              signed integer that uniquely identifies the specific instance of
              YYFILL(n) that is about to be called.  Should the user  wish  to
              save  the  state of the scanner and have YYFILL(n) return to the
              caller, all he has to do is store that  unique  identifer  in  a
              variable.   Later,  when  the scannered is called again, it will
              call YYGETSTATE() and resume execution right where it left  off.
              The  generated  code  will contain both YYSETSTATE(s) and YYGET-
              STATE even if YYFILL(n) is being disabled.


SSCCAANNNNEERR WWIITTHH SSTTOORRAABBLLEE SSTTAATTEESS
       When the --ff flag is specified, rree22cc generates a scanner that can  store
       its  current  state,  return to the caller, and later resume operations
       exactly where it left off.

       The default operation of rree22cc is a "pull" model, where the scanner asks
       for  extra  input whenever it needs it. However, this mode of operation
       assumes that the scanner is the "owner" the parsing loop, and that  may
       not always be convenient.

       Typically,  if  there  is  a  preprocessor  ahead of the scanner in the
       stream, or for that matter any other procedural  source  of  data,  the
       scanner  cannot "ask" for more data unless both scanner and source live
       in a separate threads.

       The --ff flag is useful for just this situation : it  lets  users  design
       scanners  that  work  in  a "push" model, i.e. where data is fed to the
       scanner chunk by chunk. When the scanner runs out of data  to  consume,
       it  just  stores  its  state, and return to the caller. When more input
       data is fed to the scanner, it resumes operations exactly where it left
       off.

       When  using  the -f option rree22cc does not accept stdin because it has to
       do the full generation process twice which means it  has  to  read  the
       input  twice.  That  means  rree22cc  would fail in case it cannot open the
       input twice or reading the input for the first time influences the sec-
       ond read attempt.

       Changes needed compared to the "pull" model.

       1. User has to supply macros YYSETSTATE() and YYGETSTATE(state)

       2. The --ff option inhibits declaration of _y_y_c_h and _y_y_a_c_c_e_p_t. So the user
       has to declare these. Also the user has to save and restore  these.  In
       the  example _e_x_a_m_p_l_e_s_/_p_u_s_h_._r_e these are declared as fields of the (C++)
       class of which the scanner is a method, so  they  do  not  need  to  be
       saved/restored  explicitly.  For  C they could e.g. be made macros that
       select fields from a structure passed in as  parameter.  Alternatively,
       they could be declared as local variables, saved with YYFILL(n) when it
       decides to return and restored at entry to the function. Also, it could
       be  more  efficient  to  save  the  state from YYFILL(n) because YYSET-
       STATE(state) is called unconditionally. YYFILL(n) however does not  get
       _s_t_a_t_e as parameter, so we would have to store state in a local variable
       by YYSETSTATE(state).

       3. Modify YYFILL(n) to return (from the function calling  it)  if  more
       input is needed.

       4. Modify caller to recognise "more input is needed" and respond appro-
       priately.

       5. The generated code will contain a  switch  block  that  is  used  to
       restores  the  last  state  by jumping behind the corrspoding YYFILL(n)
       call. This code is automatically generated in the epilog of  the  first
       "/*!re2c */" block.  It is possible to trigger generation of the YYGET-
       STATE() block earlier by placing a "/*!getstate:re2c */" comment.  This
       is  especially  useful when the scanner code should be wrapped inside a
       loop.

       Please see examples/push.re for push-model scanner. The generated  code
       can   be   tweaked   using  inplace  configurations  "ssttaattee::aabboorrtt"  and
       "ssttaattee::nneexxttllaabbeell".


SSCCAANNNNEERR WWIITTHH CCOONNDDIITTIIOONN SSUUPPPPOORRTT
       You can preceed regular-expressions with a list of condition names when
       using  the  --cc  switch.  In this case rree22cc generates scanner blocks for
       each conditon. Where each of the generated blocks has its own precondi-
       tion.  The  precondition is given by the interface define YYYYGGEETTCCOONNDDIITTOONN
       and must be of type YYYYCCOONNDDTTYYPPEE.

       There are two special rule types. First, the rules of the condition ’*’
       are  merged  to  all   conditions.  And second the empty condition list
       allows to provide a code block that does not have a scanner part. Mean-
       ing  it  does  not  allow  any  regular expression. The condition value
       referring to this special block is always the one with the  enumeration
       value 0. This way the code of this special rule can be used to initial-
       ize a scanner. It is in no way necessary to have these rules: but some-
       times  it is helpful to have a dedicated uninitialized condition state.

       Non empty rules allow to specify the new condition,  which  makes  them
       transition  rules. Besides generating calls for the define YYYYSSEETTCCOONNDDTTII--
       TTIIOONN no other special code is generated.

       There is another kind of special rules that allow to  prepend  code  to
       any  code  block  of all rules of a certain set of conditions or to all
       code blocks to all rules. This can be helpful when  some  operation  is
       common  among  rules. For instance this can be used to store the length
       of the scanned string. These special setup rules start with an exclama-
       tion  mark  followed by either a list of conditions <<!! ccoonnddiittiioonn,, ...... >>
       or a star <<!!**>>.  When rree22cc generates the code for a  rule  whose  state
       does  not  have  a  setup rule and a star’d setup rule is present, than
       that code will be used as setup code.


SSCCAANNNNEERR SSPPEECCIIFFIICCAATTIIOONNSS
       Each scanner specification consists of a set of  _r_u_l_e_s,  _n_a_m_e_d  _d_e_f_i_n_i_-
       _t_i_o_n_s and _c_o_n_f_i_g_u_r_a_t_i_o_n_s.

       _R_u_l_e_s  consist of a regular-expression along with a block of C/C++ code
       that is to  be  executed  when  the  associated  _r_e_g_u_l_a_r_-_e_x_p_r_e_s_s_i_o_n  is
       matched.  You  can either start the code with an opening curly brace or
       the sequence ’::==’. When the code with a curly brace  then  rree22cc  counts
       the  brace  depth  and  stops looking for code automatically. Otherwise
       curly braces are not allowed and rree22cc stops looking  for  code  at  the
       first line that does not begin with whitespace.

              _r_e_g_u_l_a_r_-_e_x_p_r_e_s_s_i_o_n { _C_/_C_+_+ _c_o_d_e }

              _r_e_g_u_l_a_r_-_e_x_p_r_e_s_s_i_o_n := _C_/_C_+_+ _c_o_d_e

       If  --cc is active then each regular-expression is preceeded by a list of
       comma separated condition names. Besides normal naming rules there  are
       two special cases. A rule may contain the single condition name ’*’ and
       no contition name at all. In the latter case the  rule  cannot  have  a
       regular-expression.  Non  empty  rules may further more specify the new
       condition. In that case rree22cc  will  generated  the  necessary  code  to
       chnage  the  condition automatically. Just as above code can be started
       with a curly brace of the sequence ’::==’. Further  more  rules  can  use
       ’:=>’  as  a shortcut to automatically generate code that not only sets
       the new condition state but  also  continues  execution  with  the  new
       state. A shortcut rule should not be used in a loop where there is code
       between the start of the loop and the rree22cc block unless  _r_e_2_c_:_c_o_n_d_:_g_o_t_o
       is changed to ’_c_o_n_t_i_n_u_e_;’. If code is necessary before all rule (though
       not simple jumps) you can doso by using <! pseudo-rules.

              <_c_o_n_d_i_t_i_o_n_-_l_i_s_t> _r_e_g_u_l_a_r_-_e_x_p_r_e_s_s_i_o_n { _C_/_C_+_+ _c_o_d_e }

              <_c_o_n_d_i_t_i_o_n_-_l_i_s_t> _r_e_g_u_l_a_r_-_e_x_p_r_e_s_s_i_o_n := _C_/_C_+_+ _c_o_d_e

              <_c_o_n_d_i_t_i_o_n_-_l_i_s_t> _r_e_g_u_l_a_r_-_e_x_p_r_e_s_s_i_o_n => _c_o_n_d_i_t_i_o_n { _C_/_C_+_+ _c_o_d_e }

              <_c_o_n_d_i_t_i_o_n_-_l_i_s_t> _r_e_g_u_l_a_r_-_e_x_p_r_e_s_s_i_o_n => _c_o_n_d_i_t_i_o_n := _C_/_C_+_+ _c_o_d_e

              <_c_o_n_d_i_t_i_o_n_-_l_i_s_t> _r_e_g_u_l_a_r_-_e_x_p_r_e_s_s_i_o_n :=> _c_o_n_d_i_t_i_o_n

              <_*> _r_e_g_u_l_a_r_-_e_x_p_r_e_s_s_i_o_n { _C_/_C_+_+ _c_o_d_e }

              <_*> _r_e_g_u_l_a_r_-_e_x_p_r_e_s_s_i_o_n := _C_/_C_+_+ _c_o_d_e

              <_*> _r_e_g_u_l_a_r_-_e_x_p_r_e_s_s_i_o_n => _c_o_n_d_i_t_i_o_n { _C_/_C_+_+ _c_o_d_e }

              <_*> _r_e_g_u_l_a_r_-_e_x_p_r_e_s_s_i_o_n => _c_o_n_d_i_t_i_o_n := _C_/_C_+_+ _c_o_d_e

              <_*> _r_e_g_u_l_a_r_-_e_x_p_r_e_s_s_i_o_n :=> _c_o_n_d_i_t_i_o_n

              <> { _C_/_C_+_+ _c_o_d_e }

              <> := _C_/_C_+_+ _c_o_d_e

              <> => _c_o_n_d_i_t_i_o_n { _C_/_C_+_+ _c_o_d_e }

              <> => _c_o_n_d_i_t_i_o_n := _C_/_C_+_+ _c_o_d_e

              <> :=> _c_o_n_d_i_t_i_o_n

              <!_c_o_n_d_i_t_i_o_n_-_l_i_s_t> { _C_/_C_+_+ _c_o_d_e }

              <!_c_o_n_d_i_t_i_o_n_-_l_i_s_t> := _C_/_C_+_+ _c_o_d_e

              <!*> { _C_/_C_+_+ _c_o_d_e }

              <!*> := _C_/_C_+_+ _c_o_d_e

       Named definitions are of the form:

              _n_a_m_e = _r_e_g_u_l_a_r_-_e_x_p_r_e_s_s_i_o_n;

       --FF is active, then named definitions are also of the form:

              _n_a_m_e _r_e_g_u_l_a_r_-_e_x_p_r_e_s_s_i_o_n

       Configurations look like  named  definitions  whose  names  start  with
       "rree22cc::":

              re2c:_n_a_m_e = _v_a_l_u_e;
              re2c:_n_a_m_e = ""_v_a_l_u_e"";


SSUUMMMMAARRYY OOFF RREE22CC RREEGGUULLAARR--EEXXPPRREESSSSIIOONNSS
       "foo"  the literal string foo.  ANSI-C escape sequences can be used.

       the  literal string foo (characters [a-zA-Z] treated case-insensitive).
              ANSI-C escape sequences can be used.

       [xyz]  a  "character  class";  in  this  case,  the  regular-expression
              matches either an ’x’, a ’y’, or a ’z’.

       [abj-oZ]
              a "character class" with a range in it; matches an ’a’,  a  ’b’,
              any letter from ’j’ through ’o’, or a ’Z’.

       [^_c_l_a_s_s]
              an inverted "character class".

       _r\_s    match  any  _r  which isn’t an _s. _r and _s must be regular-expres-
              sions which can be expressed as character classes.

       _r*     zero or more _r’s, where _r is any regular-expression

       _r+     one or more _r’s

       _r?     zero or one _r’s (that is, "an optional _r")

       name   the expansion of the "named definition" (see above)

       (_r)    an _r; parentheses are used to override precedence (see below)

       _r_s     an _r followed by an _s ("concatenation")

       _r|_s    either an _r or an _s

       _r/_s    an _r but only if it is followed by an _s. The _s is  not  part  of
              the  matched  text.  This  type  of regular-expression is called
              "trailing context". A trailing context can only be the end of  a
              rule and not part of a named definition.

       _r{_n}   matches _r exactly _n times.

       _r{_n,}  matches _r at least _n times.

       _r{_n,_m} matches _r at least _n but not more than _m times.

       match any character except newline (\n).

       _d_e_f    matches  named definition as specified by _d_e_f only if --FF is off.
              If the switch --FF  is  active  then  this  behaves  like  it  was
              enclosed in double quotes and matches the string _d_e_f.

       Character classes and string literals may contain octoal or hexadecimal
       character definitions and the following set of escape sequences (\\nn,
        \\tt, \\vv, \\bb, \\rr, \\ff, \\aa, \\\\).  An octal character is defined by a back-
       slash followed by its three octal digits and a hexadecimal character is
       defined by backslash, a lower cased ’xx’ and its two hexadecimal  digits
       or a backslash, an upper cased XX and its four hexadecimal digits.

       rree22cc  further more supports the c/c++ unicode notation. That is a back-
       slash followed by either a lowercased uu and its four hexadecimal digits
       or an uppercased UU and its eight hexadecimal digits. However only in --uu
       mode the generated code can deal with any valid Unicode character up to
       0x10FFFF.

       Since  characters  greater  \\XX0000FFFF are not allowed in non unicode mode,
       the only portable "aannyy" rules are ((..||""\\nn"")) and [[^^]].

       The regular-expressions listed above are grouped  according  to  prece-
       dence,  from  highest  precedence  at  the top to lowest at the bottom.
       Those grouped together have equal precedence.


IINNPPLLAACCEE CCOONNFFIIGGUURRAATTIIOONN
       It is possible to configure code generation  inside  rree22cc  blocks.  The
       following lists the available configurations:

       _r_e_2_c_:_c_o_n_d_p_r_e_f_i_x == yyc_ ;;
              Allows  to specify the prefix used for condition labels. That is
              this text is prepended to any condition label in  the  generated
              output file.

       _r_e_2_c_:_c_o_n_d_e_n_u_m_p_r_e_f_i_x == yyc ;;
              Allows  to specify the prefix used for condition values. That is
              this text is prepended to any condition enum value in the gener-
              ated output file.

       _r_e_2_c_:_c_o_n_d_:_d_i_v_i_d_e_r == "/* *********************************** */" ;;
              Allows  to  customize  the devider for condition blocks. You can
              use ’@@’ to put the name of the condition or ustomize the  plae-
              holder using _r_e_2_c_:_c_o_n_d_:_d_i_v_i_d_e_r_@_c_o_n_d.

       _r_e_2_c_:_c_o_n_d_:_d_i_v_i_d_e_r_@_c_o_n_d == @@ ;;
              Specifies  the placeholder that will be replaced with the condi-
              tion name in _r_e_2_c_:_c_o_n_d_:_d_i_v_i_d_e_r.

       _r_e_2_c_:_c_o_n_d_:_g_o_t_o == "goto @@;" ;;
              Allows to customize the  condition  goto  statements  used  with
              ’:=>’ style rules.  You can use ’@@’ to put the name of the con-
              dition or ustomize the plaeholder using _r_e_2_c_:_c_o_n_d_:_g_o_t_o_@_c_o_n_d. You
              can  also  change  this to ’continue;’, which would allow you to
              continue with the next loop cycle  including  any  code  between
              loop start and re2c block.

       _r_e_2_c_:_c_o_n_d_:_g_o_t_o_@_c_o_n_d == @@ ;;
              Spcifies  the  placeholder that will be replaced with the condi-
              tion label in _r_e_2_c_:_c_o_n_d_:_g_o_t_o.

       _r_e_2_c_:_i_n_d_e_n_t_:_t_o_p == 0 ;;
              Specifies the minimum number of indendation to use.  Requires  a
              numeric value greater than or equal zero.

       _r_e_2_c_:_i_n_d_e_n_t_:_s_t_r_i_n_g == "\t" ;;
              Specifies  the  string to use for indendation. Requires a string
              that should contain only whitespace unless  you  need  this  for
              external  tools. The easiest way to specify spaces is to enclude
              them in single or double quotes. If you do not want any indenda-
              tion at all you can simply set this to """".

       _r_e_2_c_:_y_y_c_h_:_c_o_n_v_e_r_s_i_o_n == 0 ;;
              When this setting is non zero, then rree22cc automatically generates
              conversion code whenever yych gets read. In this case  the  type
              must be defined using rree22cc::ddeeffiinnee::YYYYCCTTYYPPEE.

       _r_e_2_c_:_y_y_c_h_:_e_m_i_t == 1 ;;
              Generation of yyyycchh can be suppressed by setting this to 0.

       _r_e_2_c_:_y_y_b_m_:_h_e_x == 0 ;;
              If  set  to  zero then a decimal table is being used else a hex-
              adecimal table will be generated.

       _r_e_2_c_:_y_y_f_i_l_l_:_e_n_a_b_l_e == 1 ;;
              Set this to zero to suppress generation of YYFILL(n). When using
              this  be sure to verify that the generated scanner does not read
              behind input. Allowing this behavior might introduce sever secu-
              rity issues to you programs.

       _r_e_2_c_:_y_y_f_i_l_l_:_c_h_e_c_k == 1 ;;
              This  can be set 0 to suppress output of the pre condition using
              YYCURSOR and  YYLIMIT  which  becomes  usefull  when  YYLIMIT  +
              max(YYFILL) is always accessible.

       _r_e_2_c_:_y_y_f_i_l_l_:_p_a_r_a_m_e_t_e_r == 1 ;;
              Allows  to suppress parameter passing to YYYYFFIILLLL calls. If set to
              zero  then  no  parameter   is   passed   to   YYYYFFIILLLL.   However
              ddeeffiinnee::YYYYFFIILLLL@@LLEENN allows to specify a replacement string for the
              actual length value. If set to a  non  zero  value  then  YYYYFFIILLLL
              usage  will be followed by the number of requested characters in
              braces unless rree22cc::ddeeffiinnee::YYYYFFIILLLL::nnaakkeedd is  set.   Also  look  at
              rree22cc::ddeeffiinnee::YYYYFFIILLLL::nnaakkeedd and rree22cc::ddeeffiinnee::YYYYFFIILLLL@@LLEENN.

       _r_e_2_c_:_s_t_a_r_t_l_a_b_e_l == 0 ;;
              If  set  to  a non zero integer then the start label of the next
              scanner blocks will be generated even if not used by the scanner
              itself.  Otherwise the normal yyyy00 like start label is only being
              generated if needed. If set to a text value then  a  label  with
              that  text  will  be  generated regardless of whether the normal
              start label is being used or not. This setting is being reset to
              00 after a start label has been generated.

       _r_e_2_c_:_l_a_b_e_l_p_r_e_f_i_x == yy ;;
              Allows  to  change the prefix of numbered labels. The default is
              yyyy and can be set any string that is a valid label.

       _r_e_2_c_:_s_t_a_t_e_:_a_b_o_r_t == 0 ;;
              When not zero and switch -f is active then the YYGETSTATE  block
              will  contain  a  default case that aborts and a -1 case is used
              for initialization.

       _r_e_2_c_:_s_t_a_t_e_:_n_e_x_t_l_a_b_e_l == 0 ;;
              Used when -f is active to control whether the  YYGETSTATE  block
              is followed by a yyNext: label line. Instead of using yyNext you
              can usually also use configuration _s_t_a_r_t_l_a_b_e_l to  force  a  spe-
              cific  start  label or default to yy0 as start label. Instead of
              using a dedicated label it  is  often  better  to  separate  the
              YYGETSTATE  code  from  the  actual  scanner  code  by placing a
              "/*!getstate:re2c */" comment.

       _r_e_2_c_:_c_g_o_t_o_:_t_h_r_e_s_h_o_l_d == 9 ;;
              When -g is active this value specifies the complexity  threshold
              that triggers generation of jump tables rather than using nested
              if’s and decision bitfields.  The threshold is compared  against
              a  calculated  estimation of if-s needed where every used bitmap
              divides the threshold by 2.

       _r_e_2_c_:_y_y_c_h_:_c_o_n_v_e_r_s_i_o_n == 0 ;;
              When the input uses signed characters and --ss or --bb switches  are
              in  effect  re2c allows to automatically convert to the unsigned
              character type that is then necessary for  its  internal  single
              character. When this setting is zero or an empty string the con-
              version is disabled. Using a non zero number the  conversion  is
              taken from YYYYCCTTYYPPEE. If that is given by an inplace configuration
              that value is being used. Otherwise it  will  be  ((YYYYCCTTYYPPEE))  and
              changes to that configuration are  no longer possible. When this
              setting is a string the braces must be specified.  Now  assuming
              your  input  is a cchhaarr** buffer and you are using above mentioned
              switches you can set YYYYCCTTYYPPEE to uunnssiiggnneedd cchhaarr and  this  setting
              to either 11 or ""((uunnssiiggnneedd cchhaarr))"".

       _r_e_2_c_:_d_e_f_i_n_e_:_d_e_f_i_n_e_:_Y_Y_C_O_N_D_T_Y_P_E == YYCONDTYPE ;;
              Enumeration used for condition support with --cc mode.

       _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_C_T_X_M_A_R_K_E_R == YYCTXMARKER ;;
              Allows  to overwrite the define YYCTXMARKER and thus avoiding it
              by setting the value to the actual code needed.

       _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_C_T_Y_P_E == YYCTYPE ;;
              Allows to overwrite the define YYCTYPE and thus avoiding  it  by
              setting the value to the actual code needed.

       _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_C_U_R_S_O_R == YYCURSOR ;;
              Allows  to overwrite the define YYCURSOR and thus avoiding it by
              setting the value to the actual code needed.

       _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_D_E_B_U_G == YYDEBUG ;;
              Allows to overwrite the define YYYYDDEEBBUUGG and thus avoiding  it  by
              setting the value to the actual code needed.

       _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_F_I_L_L == YYFILL ;;
              Allows  to  overwrite  the define YYYYFFIILLLL and thus avoiding it by
              setting the value to the actual code needed.

       _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_F_I_L_L_:_n_a_k_e_d == 0 ;;
              When set to 1 neither braces, parameter nor semicolon gets emit-
              ted.

       _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_F_I_L_L_@_l_e_n == @@ ;;
              When  using  _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_F_I_L_L  and  _r_e_2_c_:_y_y_f_i_l_l_:_p_a_r_a_m_e_t_e_r is 0
              then any occurence of this text inside YYYYFFIILLLL will  be  replaced
              with the actual length value.

       _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_G_E_T_C_O_N_D_I_T_I_O_N == YYGETCONDITION ;;
              Allows to overwrite the define YYYYGGEETTCCOONNDDIITTIIOONN.

       _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_G_E_T_C_O_N_D_I_T_I_O_N_:_n_a_k_e_d ==  ;;
              When set to 1 neither braces, parameter nor semicolon gets emit-
              ted.

       _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_G_E_T_S_T_A_T_E == YYGETSTATE ;;
              Allows to overwrite the define YYYYGGEETTSSTTAATTEE and thus  avoiding  it
              by setting the value to the actual code needed.

       _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_G_E_T_S_T_A_T_E_:_n_a_k_e_d == 0 ;;
              When set to 1 neither braces, parameter nor semicolon gets emit-
              ted.

       _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_L_I_M_I_T == YYLIMIT ;;
              Allows to overwrite the define YYYYLLIIMMIITT and thus avoiding  it  by
              setting the value to the actual code needed.

       _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_M_A_R_K_E_R == YYMARKER ;;
              Allows  to overwrite the define YYYYMMAARRKKEERR and thus avoiding it by
              setting the value to the actual code needed.

       _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_S_E_T_C_O_N_D_I_T_I_O_N == YYSETCONDITION ;;
              Allows to overwrite the define YYYYSSEETTCCOONNDDIITTIIOONN.

       _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_S_E_T_C_O_N_D_I_T_I_O_N_@_c_o_n_d == @@ ;;
              When using _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_S_E_T_C_O_N_D_I_T_I_O_N then any occurence of this
              text  inside YYYYSSEETTCCOONNDDIITTIIOONN will be replaced with the actual new
              condition value.

       _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_S_E_T_S_T_A_T_E == YYSETSTATE ;;
              Allows to overwrite the define YYYYSSEETTSSTTAATTEE and thus  avoiding  it
              by setting the value to the actual code needed.

       _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_S_E_T_S_T_A_T_E_:_n_a_k_e_d == 0 ;;
              When set to 1 neither braces, parameter nor semicolon gets emit-
              ted.

       _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_S_E_T_S_T_A_T_E_@_s_t_a_t_e == @@ ;;
              When using _r_e_2_c_:_d_e_f_i_n_e_:_Y_Y_S_E_T_S_T_A_T_E then  any  occurence  of  this
              text  inside  YYYYSSEETTSSTTAATTEE  will  be  replaced with the actual new
              state value.

       _r_e_2_c_:_l_a_b_e_l_:_y_y_F_i_l_l_L_a_b_e_l == yyFillLabel ;;
              Allows to overwrite the name of the label yyFillLabel.

       _r_e_2_c_:_l_a_b_e_l_:_y_y_N_e_x_t == yyNext ;;
              Allows to overwrite the name of the label yyNext.

       _r_e_2_c_:_v_a_r_i_a_b_l_e_:_y_y_a_c_c_e_p_t == yyaccept ;;
              Allows to overwrite the name of the variable yyaccept.

       _r_e_2_c_:_v_a_r_i_a_b_l_e_:_y_y_b_m == yybm ;;
              Allows to overwrite the name of the variable yybm.

       _r_e_2_c_:_v_a_r_i_a_b_l_e_:_y_y_c_h == yych ;;
              Allows to overwrite the name of the variable yych.

       _r_e_2_c_:_v_a_r_i_a_b_l_e_:_y_y_c_t_a_b_l_e == yyctable ;;
              When both --cc and --gg are active then rree22cc uses this  variable  to
              generate a static jump table for YYGETCONDITION.

       _r_e_2_c_:_v_a_r_i_a_b_l_e_:_y_y_s_t_a_b_l_e == yystable ;;
              When  both  --ff and --gg are active then rree22cc uses this variable to
              generate a static jump table for YYGETSTATE.

       _r_e_2_c_:_v_a_r_i_a_b_l_e_:_y_y_t_a_r_g_e_t == yytarget ;;
              Allows to overwrite the name of the variable yytarget.


UUNNDDEERRSSTTAANNDDIINNGG RREE22CC
       The subdirectory lessons of the rree22cc distribution contains a  few  step
       by  step  lessons  to  get  you  started with rree22cc. All examples in the
       lessons subdirectory can be compiled and actually work.


FFEEAATTUURREESS
       rree22cc does not provide a default action: the generated code assumes that
       the  input will consist of a sequence of tokens.  Typically this can be
       dealt with by adding a rule such as the one for  unexpected  characters
       in the example above.

       The  user  must  arrange  for  a sentinel token to appear at the end of
       input (and provide a rule for matching it): rree22cc does  not  provide  an
       <<EOF>>  expression.   If  the  source  is  from a null-byte terminated
       string, a rule matching a null character will suffice.  If  the  source
       is  from  a  file  then you could pad the input with a newline (or some
       other character that cannot appear within another token);  upon  recog-
       nizing  such  a  character  check  to see if it is the sentinel and act
       accordingly. And you can also use YYFILL(n) to end the scanner in  case
       not enough characters are available which is nothing else then e detec-
       tion of end of data/file.


BBUUGGSS
       Difference only works for character sets.

       The rree22cc internal algorithms need documentation.


SSEEEE AALLSSOO
       flex(1), lex(1).

       More information on rree22cc can be found here:
       hhttttpp::////rree22cc..oorrgg//


AAUUTTHHOORRSS
       Peter Bumbulis <peter@csg.uwaterloo.ca>
       Brian Young <bayoung@acm.org>
       Dan Nuffer <nuffer@users.sourceforge.net>
       Marcus Boerger <helly@users.sourceforge.net>
       Hartmut Kaiser <hkaiser@users.sourceforge.net>
       Emmanuel Mogenet <mgix@mgix.com> added storable state


VVEERRSSIIOONN IINNFFOORRMMAATTIIOONN
       This manpage describes re2c, version 0.13.5.

Version 0.13.5                    12 Jul 2010                          RE2C(1)